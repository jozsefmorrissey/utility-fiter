<!DOCTYPE html>
<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="/js/three.js"></script>
    <script type="module">

      // Find the latest version by visiting https://unpkg.com/three. The URL will
      // redirect to the newest stable release.
      import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';

      // const controls = new OrbitControls();

      let part;
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      const renderer = new THREE.WebGLRenderer();
      const controls = new OrbitControls( camera, renderer.domElement );

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

      function createPart(length, width, height) {
        const geometry = new THREE.BoxGeometry(length, width, height);
        const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
        if (part) scene.remove(part);
        part = new THREE.Mesh( geometry, material );
        scene.add( part );
      }
// createPart(2,1,3);
			camera.position.z = 5;

			const animate = function () {
				requestAnimationFrame( animate );

				// plane.rotation.x += 0.01;
				// plane.rotation.y += 0.01;
        controls.update();

				renderer.render( scene, camera );
			};

      // const points = [];
      // points.push( new THREE.Vector3( 10, 0, 0 ) );
      // points.push( new THREE.Vector3( 0, 10, 0 ) );
      // points.push( new THREE.Vector3( 10, 0, 0 ) );
      //
      // const geometry = new THREE.BufferGeometry().setFromPoints( points );
      // const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      // const line = new THREE.Line( geometry, material );
      // scene.add(line);

      function makePart(length, width, height) {
        // const geometry = new THREE.PlaneGeometry(length, width);
        // const material = new THREE.MeshBasicMaterial( {color: 0x00ff00, side: THREE.DoubleSide} );
        // const material2 = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
        // const plane = new THREE.Mesh( geometry, material );
        // const plane2 = new THREE.Mesh( geometry, material2 );
        // plane2.translateZ( height );
        // scene.add( plane );
        // scene.add( plane2 );
				//
        // const geometry2 = new THREE.PlaneGeometry(length, height);
        // const plane3 = new THREE.Mesh( geometry2, material );
        // const plane4 = new THREE.Mesh( geometry2, material2 );
        // plane3.rotation.x += 1.5708;
        // plane3.translateX( 3 );
        // plane4.translateX( -3 );
        // scene.add( plane3 );
        // scene.add( plane4 );

				// const geometryc = new THREE.BoxGeometry( 20, 5, 1 );
				// const materialc = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
				// const cube = new THREE.Mesh( geometryc, materialc );
				// scene.add( cube );
				//
				// const geometryc2 = new THREE.BoxGeometry( 20, 1, 5 );
				// const materialc2 = new THREE.MeshBasicMaterial( {color: 0xffff00} );
				// const cube2 = new THREE.Mesh( geometryc2, materialc2 );
				// cube2.translateY(2);
				// cube2.translateZ(3);
				// scene.add( cube2 );

				// const geometry = new THREE.Geometry();
				// geometry.vertices.push(
				// );
				function attrsEqual(obj1, obj2) {
					const equalList = [];
					for (let index = 2; index < arguments.length; index +=1) {
						const attr = arguments[index];
						if (obj1[attr] === obj2[attr]) equalList.push(attr);
					}
					return equalList;
				}

				const sqrt = Math.sqrt;
				const pow = Math.pow;
				function distance(p1, p2) {
					return sqrt(pow(p1.x - p2.x, 2) + pow(p1.z - p2.z, 2) + pow(p1.z - p2.z, 2));
				}

				function closer(target) {
					let closest;
					for (let index = 1; index < arguments.length; index += 1) {
						const dist = distance(target, arguments[index]);
						if (closest === undefined || closest.dist > dist) {
							closest = {dist, index: index - 1};
						}
					}
					return closest.index;
				}

				function renderSquaredObj(points) {
					const vectors = [];
					const faces = {};
					const facesCovered = {};
					for (let index1 = 0; index1 < points.length; index1 += 1) {
						const vectorId = () => `${v1}`
						const point1 = points[index1];
						const closestPoints = {};
						vectors.push(new THREE.Vector3(point1.x, point1.y, point1.z));
						for (let index2 = 0; index2 < points.length; index2 += 1) {
							const point2 = points[index2];
							const equalList = attrsEqual(point1, point2, 'x', 'y', 'z');
							if (equalList.length === 2) {
								const cpId = equalList.join('');
								const cp = closestPoints[cpId];
								if (cp === undefined || closer(point1, point2, cp.point) === 0) {
									closestPoints[cpId] = {point: point2, index: index2};
								}
							}
						}
						const keys = Object.keys(closestPoints);
						if (keys.length !== 3) throw Error('closestPoint malfunction');
						const neighbors = [];
						keys.forEach((key) => {
							const value = closestPoints[key];
							if (facesCovered[value.index] === undefined) facesCovered[value.index] = {};
							if (facesCovered[value.index][key] === undefined) {
								facesCovered[value.index][key] = true;
								neighbors.push(value.index);
							}
						});
						let indexes = [index1];
						indexes.push(neighbors[1], neighbors[2]);
						indexes.sort();
						if (indexes[0] !== undefined && indexes[1] !== undefined && indexes[2] !== undefined)
							faces[indexes.join()] = new THREE.Face3(...indexes);
						indexes = [index1];
						indexes.push(neighbors[2], neighbors[3]);
						indexes.sort();
						if (indexes[0] !== undefined && indexes[1] !== undefined && indexes[2] !== undefined)
							faces[indexes.join()] = new THREE.Face3(...indexes);
						indexes = [index1];
						indexes.push(neighbors[1], neighbors[3]);
						indexes.sort();
						if (indexes[0] !== undefined && indexes[1] !== undefined && indexes[2] !== undefined)
							faces[indexes.join()] = new THREE.Face3(...indexes);
					}

					const geometry = new THREE.Geometry();
					geometry.vertices.push(...vectors);
					geometry.faces.push(...Object.values(faces));

					const material = new THREE.MeshBasicMaterial( {color: 0x0000ff, transparent: false,
						side: THREE.DoubleSide} );
					const cube2 = new THREE.Mesh( geometry, material );
					cube2.rotation.x = Math.PI / 2;
					scene.add( cube2 );
				}

				let points = [
					{x: 0,y: 0,z: 0}, // 0
					{x: 0,y: 0,z: 1}, // 1
					{x: 3,y: 0,z: 0}, // 2
					{x: 3,y: 0,z: 1}, // 3
					{x: 0,y: 5,z: 0}, // 4
					{x: 3,y: 5,z: 0}, // 5
					{x: 3,y: 5,z: 1}, // 6
					{x: 0,y: 5,z: 1}, // 7
				];

				points = [{x: 0,y: 0,z: 0}, // 0
					{x: 0,y: 0,z: 1}, // 1
					{x: 3,y: 0,z: 0}, // 2
					{x: 3,y: 0,z: 1}, // 3
					{x: 0,y: 5,z: 0}, // 4
					{x: 3,y: 5,z: 0}, // 5
					{x: 3,y: 5,z: 1}, // 6
					{x: 0,y: 5,z: 1}, // 7
					{x: 3,y: 2,z: 0}, // 8
					{x: 3,y: 2,z: 1}, // 9
					{x: 2,y: 2,z: 0}, // 10
					{x: 2,y: 2,z: 1}, // 11
					{x: 2,y: 3,z: 1}, // 12
					{x: 2,y: 3,z: 0}, // 13
					{x: 3,y: 3,z: 1}, // 14
					{x: 3,y: 3,z: 0} // 15
				];
				renderSquaredObj(points);


				// 	// front
				// 	new THREE.Face3(0, 2, 4),
				// 	// new THREE.Face3(5, 4, 2),
				// 	new THREE.Face3(5,2,4),
				// 	// back
				// 	new THREE.Face3(1, 3, 7),
				// 	new THREE.Face3(6, 7, 3),//--
				// 	// left
				// 	new THREE.Face3(0, 1, 4),
				// 	new THREE.Face3(7, 4, 1),
				// 	// top
				// 	new THREE.Face3(4,5,7),
				// 	new THREE.Face3(6,7,5),
				// 	// bottom
				// 	new THREE.Face3(0,1,2),
				// 	new THREE.Face3(3,2,1),
				// 	// // right
				// 	new THREE.Face3(2,3,5),
				// 	new THREE.Face3(6,5,3),
				// );


      }

      makePart(3, 4, .75)
			animate();
		</script>
	</body>
</html>
